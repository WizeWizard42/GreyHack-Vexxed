// Exploiter class. Handles all the dirty work of storing, loading, finding, and exploiting vulns.
Exploiter = {}

Exploiter.scanResult = {} // {"(libname)-(libversion)": {"(memory)": ["(value)", "(value)", ...], ...}, ...}

Exploiter.metaLibs = {} // {"(libname)-(libversion): metaLib", ...}

// Parses sec values from overflow output as a list.
Exploiter.scanParse = function(results)
	found = false
	payloads = []
	line = results.split(" ")
	line.reverse

	for word in line
		if found == true then
			word = word.remove(".")
			word = word.remove("<b>")
			word = word.remove("</b>")
			payloads.push(word)
			found = false
		end if

		if word == "Buffer" then
            found = true
		end if
	end for

	return payloads
end function

// Loads a local lib specified by path, used in local exploits. Returns a list of metaLib and lib_id.
Exploiter.loadLib = function(filePath)
	metaLib = metaxploit.load(filePath)
	if metaLib then return metaLib

	print("Library was unable to be loaded.")
end function

// Scans provided MetaLib and saves result vulns. Returns lib_id.
Exploiter.scanLib = function(metaLib)
	lib_id = metaLib.lib_name + "-" + metaLib.version
	self.metaLibs[lib_id] = metaLib

	if self.scanResult.hasIndex(lib_id) then return

	self.scanResult[lib_id] = {}

	memories = metaxploit.scan(metaLib)
	for memory in memories
		print("Scanning memory: " + memory)
		self.scanResult[lib_id][memory] = self.scanParse(metaxploit.scan_address(metaLib, memory))
	end for

	self.saveResult
	return lib_id
end function

// Loads a lib from a remote computer, used in remote exploits. Returns a NetSession object.
Exploiter.loadRemoteLib = function(ip, port)
	netSession = metaxploit.net_use(ip, port)
	if netSession then return netSession.dump_lib
	print("Remote library was unable to be loaded.")
end function

// Scans respective port's MetaLib and returns lib_id, used as an id in other methods.
Exploiter.scanPort = function(ip, port)
	metaLib = self.loadRemoteLib(ip, port)
	if not metaLib then return

	self.scanLib(metaLib)
	return metaLib.lib_name + "-" + metaLib.version
end function

// Saves in-memory vulns to a file, to be parsed later.
Exploiter.saveResult = function()
    c = get_shell.host_computer

    if not c.File(current_path + "/payloads.db") then
        c.touch(current_path, "payloads.db")
    end if
    database_file = c.File(current_path + "/payloads.db")

	result_string = ""

    for lib_id in self.scanResult.indexes
		result_string = result_string + lib_id + ":"
		for memory in self.scanResult[lib_id].indexes
			result_string = result_string + memory + ";"
			result_string = result_string + self.scanResult[lib_id][memory].join(",") + "."
		end for
		result_string = result_string + "#"
	end for

	database_file.set_content(result_string)
end function

// Parses payloads.db from current directory and stores in-memory.
Exploiter.loadResult = function()
	c = get_shell.host_computer

    if not c.File(current_path + "/payloads.db") then
        self.scanResult = {}
    else
		database_file = c.File(current_path + "/payloads.db")

		entries = database_file.get_content.split("#")
		entries.pop

		for entry in entries
			entry = entry.split(":")
			memory_entries = entry[1].split("\.")
			memory_entries.pop

			self.scanResult[entry[0]] = {}

			for memory_entry in memory_entries
				memory_entry = memory_entry.split(";")
				self.scanResult[entry[0]][memory_entry[0]] = memory_entry[1].split(",")
			end for
		end for
	end if
end function

Exploiter.resultObjects = {}

// Given a library id and optional key, pulls MetaLib from loaded libraries and stores successful attacks.
Exploiter.crackLib = function(lib_id, overflowKey)
    if self.resultObjects.hasIndex(lib_id) then
        return
    end if  

    self.resultObjects[lib_id] = []

    metaLib = self.metaLibs[lib_id]
    lib_vulns = self.scanResult[lib_id]

    for memory in lib_vulns.indexes
        for value in lib_vulns[memory]
            result = metaLib.overflow(memory, value, overflowKey)
            if result and typeof(result) != "number" then
                if typeof(result) == "file" then
                    file = new FileHandler
                    file.updateFileObject(result)
                    self.resultObjects[lib_id].push(file)
                end if
                if typeof(result) == "computer" then
                    computer = new ComputerHandler
                    computer.updateComputerObject(result)
                    self.resultObjects[lib_id].push(computer)
                end if
                if typeof(result) == "shell" then
                    shell = new ShellHandler
                    shell.updateShellObject(result)
                    self.resultObjects[lib_id].push(shell)
                end if 
            end if
        end for
    end for
end function

// Prints all successful attacks for provided library id.
Exploiter.printVulns = function(lib_id)
    print("Listing stored vulns for: " + lib_id)
    for i in range(0, self.resultObjects[lib_id].len - 1, 1)
        print(i + ": " + self.resultObjects[lib_id][i].getPerms + "    " + typeof(self.resultObjects[lib_id][i].getObject).color("blue") + "    " + self.resultObjects[lib_id][i].getLANIP)
    end for
end function
