// Exploiter class. Handles all the dirty work of storing, loading, finding, and exploiting vulns.
Exploiter = {}

Exploiter.scanResult = {} // {"(libname)-(libversion)": {"(memory)": ["(value)", "(value)", ...], ...}, ...}

Exploiter.metaLibs = {} // {"(libname)-(libversion): metaLib", ...}

// Parses sec values from overflow output as a list.
Exploiter.scanParse = function(results)
	found = false
	payloads = []
	line = results.split(" ")
	line.reverse

	for word in line
		if found == true then
			word = word.remove(".")
			word = word.remove("<b>")
			word = word.remove("</b>")
			payloads.push(word)
			found = false
		end if

		if word == "Buffer" then
            found = true
		end if
	end for

	return payloads
end function

// Loads a local lib specified by path, used in local exploits. Returns a list of metaLib and lib_id.
Exploiter.loadLib = function(filePath)
	metaLib = session.vexxed["remoteMetax"].load(filePath)
	if metaLib then return metaLib

	print("Library was unable to be loaded.")
end function

// Scans provided MetaLib and saves result vulns. Returns lib_id.
Exploiter.scanLib = function(metaLib)
	lib_id = metaLib.lib_name + "-" + metaLib.version
	self.metaLibs[lib_id] = metaLib

	if self.scanResult.hasIndex(lib_id) then return lib_id

	self.scanResult[lib_id] = {}

	memories = session.vexxed["homeMetax"].scan(metaLib)
	for memory in memories
		print("Scanning memory: " + memory)
		self.scanResult[lib_id][memory] = self.scanParse(session.vexxed["homeMetax"].scan_address(metaLib, memory))
	end for

	self.saveResult
	return lib_id
end function

// Loads a lib from a remote computer, used in remote exploits. Returns a NetSession object.
Exploiter.loadRemoteLib = function(ip, port)
	netSession = session.vexxed["remoteMetax"].net_use(ip, port)
	if netSession then return netSession.dump_lib
	print("Remote library was unable to be loaded.")
end function

// Scans respective port's MetaLib and returns lib_id, used as an id in other methods.
Exploiter.scanPort = function(ip, port)
	metaLib = self.loadRemoteLib(ip, port)
	if not metaLib then return

	self.scanLib(metaLib)
	return metaLib.lib_name + "-" + metaLib.version
end function

// Saves in-memory vulns to a file, to be parsed later.
Exploiter.saveResult = function()
    c = session.vexxed["homeShell"].host_computer

    if not c.File("/root/payloads.db") then
        c.touch("/root", "payloads.db")
    end if
    database_file = c.File("/root/payloads.db")

	result_string = ""

    for lib_id in self.scanResult.indexes
        result_string = result_string + lib_id + "|"
        
        memory_values = []
        for memory in self.scanResult[lib_id].indexes
            values = self.scanResult[lib_id][memory].join(",")
            memory_values.push(memory + ":" + values)
        end for
        
        result_string = result_string + memory_values.join("|") + char(10)
    end for

    database_file.set_content(result_string)
end function

// Parses payloads.db from current directory and stores in-memory.
Exploiter.loadResult = function()
c = session.vexxed["homeShell"].host_computer

if not c.File("/root/payloads.db") then
	self.scanResult = {}
else
	content = c.File("/root/payloads.db").get_content

	if content.len == 0 then
		self.scanResult = {}
	else
		lines = content.split(char(10))

		for line in lines
			if line.trim.len == 0 then continue

			parts = line.split("\|")
			lib_id = parts[0]
			memory_values_pairs = parts[1:]

			self.scanResult[lib_id] = {}

			for pair in memory_values_pairs
				memory_values = pair.split(":")
				memory = memory_values[0]
				values = memory_values[1].split(",")
				self.scanResult[lib_id][memory] = values
			end for
		end for
	end if
end if
end function

Exploiter.resultObjects = {}

// Given a library id and optional key, pulls MetaLib from loaded libraries and stores successful attacks.
Exploiter.crackLib = function(lib_id, overflowKey)
	result_id = lib_id + overflowKey
    if self.resultObjects.hasIndex(result_id) then
        return
    end if  

    self.resultObjects[result_id] = []

    metaLib = self.metaLibs[lib_id]
    lib_vulns = self.scanResult[lib_id]

    for memory in lib_vulns.indexes
        for value in lib_vulns[memory]
            result = metaLib.overflow(memory, value, overflowKey)
            if result and typeof(result) != "number" then
                if typeof(result) == "file" then
                    file = new FileHandler
                    file.updateFileObject(result)
                    self.resultObjects[result_id].push(file)
                end if
                if typeof(result) == "computer" then
                    computer = new ComputerHandler
                    computer.updateComputerObject(result)
                    self.resultObjects[result_id].push(computer)
                end if
                if typeof(result) == "shell" then
                    shell = new ShellHandler
                    shell.updateShellObject(result)
                    self.resultObjects[result_id].push(shell)
                end if 
            end if
        end for
    end for
end function

// Prints all successful attacks for provided library id.
Exploiter.printVulns = function(lib_id)
	print("Listing stored vulns for: " + lib_id)
	info = ""
	for i in range(0, self.resultObjects[lib_id].len - 1, 1)
		info = info + (str(i) + ": " + self.resultObjects[lib_id][i].getPerms + "    " + typeof(self.resultObjects[lib_id][i].getObject).color("blue") + "    " + self.resultObjects[lib_id][i].getLANIP + "\n")
	end for
	print(format_columns(info))
end function
