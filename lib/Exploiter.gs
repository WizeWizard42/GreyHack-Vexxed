// Exploiter class. Handles all the dirty work of storing, loading, finding, and exploiting vulns.
Exploiter = {}

Exploiter.scanResult = {} // {"(libname)-(libversion)": {"(memory)": ["(value)", "(value)", ...], ...}, ...}

Exploiter.metaLibs = {} // {"(libname)-(libversion): metaLib", ...}

Exploiter.inputMap = {}

Exploiter.inputMap["scan"] = function(objRef, args)
	if args.len < 3 then return "Usage: scan [ip] [port]"

	lib_id = objRef.scanPort(args[1], args[2].to_int)
	if not lib_id then return "Library was unable to be scanned." else return session.vexxed["session"].setCurrLib(lib_id)
end function

Exploiter.inputMap["load"] = function(objRef, args)
	if args.len < 2 then return "Usage: load [path]"

	lib_id = objRef.scanLib(objRef.loadLib(args[1]))
	if not lib_id then return "Library was unable to be loaded." else return session.vexxed["session"].setCurrLib(lib_id)
end function

Exploiter.inputMap["local"] = function(objRef, args)
	if args.len < 3 then return "Usage: local [path] [optVal]"

	result = objRef.inputMap.load(objRef, args)
	if result then return result
	objRef.crackLib(session.vexxed["session"].currLib, args[2])
	objRef.printVulns(session.vexxed["session"].currLib)
end function

Exploiter.inputMap["crack"] = function(objRef, args)
	if args.len < 2 then return "Usage: crack [hash/file]"

	return objRef.crackHash(args[1])
end function

Exploiter.inputMap["target"] = function(objRef, args)
	if args.len < 4 then return "Usage: target [ip] [port] [optVal]"

	result = objRef.inputMap.scan(objRef, args)
	if result then return result
	objRef.crackLib(session.vexxed["session"].currLib, args[3])
	objRef.printVulns(session.vexxed["session"].currLib)
end function

// Parses sec values from overflow output as a list.
Exploiter.scanParse = function(results)
	found = false
	payloads = []
	line = results.split(" ")
	line.reverse

	for word in line
		if found == true then
			word = word.remove(".")
			word = word.remove("<b>")
			word = word.remove("</b>")
			payloads.push(word)
			found = false
		end if

		if word == "Buffer" then
            found = true
		end if
	end for

	return payloads
end function

// Loads a local lib specified by path, used in local exploits. Returns a list of metaLib and lib_id.
Exploiter.loadLib = function(filePath)
	metaLib = session.vexxed["remoteMetax"].load(filePath)
	if metaLib then return metaLib

	print("Library was unable to be loaded.")
end function

// Scans provided MetaLib and saves result vulns. Returns lib_id.
Exploiter.scanLib = function(metaLib)
	lib_id = metaLib.lib_name + "-" + metaLib.version
	self.metaLibs[lib_id] = metaLib

	if self.scanResult.hasIndex(lib_id) then return lib_id

	self.scanResult[lib_id] = {}

	memories = session.vexxed["homeMetax"].scan(metaLib)
	for memory in memories
		print("Scanning memory: " + memory)
		self.scanResult[lib_id][memory] = self.scanParse(session.vexxed["homeMetax"].scan_address(metaLib, memory))
	end for

	self.saveResult
	return lib_id
end function

Exploiter.crackHash = function(hash)
	file = session.vexxed["session"].currHandler.checkFile(hash)
	if not file then return session.vexxed["homeCrypto"].decipher(hash)
	if file.is_folder then return GenericError.create("Error: cannot crack a folder.")

	// Credit to MachaCeleste for this snippet.
	accounts = file.get_content.split(char(10))
	info = "User Password"
	for account in accounts
	    account = account.trim
	    if account.len < 33 then continue
	    enc = account.split(":")
	    dec = decipher(session.vexxed["homeCrypto"], enc[1])
	    info = info + "\n" + enc[0] + " " + dec
	end for
	return format_columns(info)
end function

// Loads a lib from a remote computer, used in remote exploits. Returns a NetSession object.
Exploiter.loadRemoteLib = function(ip, port)
	netSession = session.vexxed["remoteMetax"].net_use(ip, port)
	if netSession then return netSession.dump_lib
	print("Remote library was unable to be loaded.")
end function

// Scans respective port's MetaLib and returns lib_id, used as an id in other methods.
Exploiter.scanPort = function(ip, port)
	metaLib = self.loadRemoteLib(ip, port)
	if not metaLib then return

	self.scanLib(metaLib)
	return metaLib.lib_name + "-" + metaLib.version
end function

// Saves in-memory vulns to a file, to be parsed later.
Exploiter.saveResult = function()
    c = session.vexxed["homeShell"].host_computer

    if not c.File("/root/Vexxed/payloads.db") then
        c.touch("/root/Vexxed", "payloads.db")
    end if
    database_file = c.File("/root/Vexxed/payloads.db")

	result_string = ""

    for lib_id in self.scanResult.indexes
        result_string = result_string + lib_id + "|"
        
        memory_values = []
        for memory in self.scanResult[lib_id].indexes
            values = self.scanResult[lib_id][memory].join(",")
            memory_values.push(memory + ":" + values)
        end for
        
        result_string = result_string + memory_values.join("|") + char(10)
    end for

    database_file.set_content(result_string)
end function

// Parses payloads.db from current directory and stores in-memory.
Exploiter.loadResult = function()
c = session.vexxed["homeShell"].host_computer

if not c.File("/root/Vexxed/payloads.db") then
	self.scanResult = {}
else
	content = c.File("/root/Vexxed/payloads.db").get_content

	if content.len == 0 then
		self.scanResult = {}
	else
		lines = content.split(char(10))

		for line in lines
			if line.trim.len == 0 then continue

			parts = line.split("\|")
			lib_id = parts[0]
			memory_values_pairs = parts[1:]

			self.scanResult[lib_id] = {}

			for pair in memory_values_pairs
				memory_values = pair.split(":")
				memory = memory_values[0]
				values = memory_values[1].split(",")
				self.scanResult[lib_id][memory] = values
			end for
		end for
	end if
end if
end function

Exploiter.resultObjects = {}

// Given a library id and optional key, pulls MetaLib from loaded libraries and stores successful attacks.
Exploiter.crackLib = function(lib_id, overflowKey)
    self.resultObjects[lib_id] = []

    metaLib = self.metaLibs[lib_id]
    lib_vulns = self.scanResult[lib_id]

    for memory in lib_vulns.indexes
        for value in lib_vulns[memory]
            result = metaLib.overflow(memory, value, overflowKey)
            if result and typeof(result) != "number" then
                if typeof(result) == "file" then
                    file = new FileHandler
                    file.updateFileObject(result)
                    self.resultObjects[lib_id].push(file)
                end if
                if typeof(result) == "computer" then
                    computer = new ComputerHandler
                    computer.updateComputerObject(result)
                    self.resultObjects[lib_id].push(computer)
                end if
                if typeof(result) == "shell" then
                    shell = new ShellHandler
                    shell.updateShellObject(result)
                    self.resultObjects[lib_id].push(shell)
                end if 
            end if
        end for
    end for
end function

// Prints all successful attacks for provided library id.
Exploiter.printVulns = function(lib_id)
	print("Listing stored vulns for: " + lib_id)
	info = ""
	for i in range(0, self.resultObjects[lib_id].len - 1, 1)
		info = info + (str(i) + ": " + self.resultObjects[lib_id][i].getPerms + "    " + typeof(self.resultObjects[lib_id][i].getObject) + "    " + self.resultObjects[lib_id][i].getLANIP + "\n")
	end for
	print(format_columns(info))
end function

Exploiter.handleInput = function(input)
	if input.len == 0 or not self.inputMap.hasMethod(input[0]) then return
			
	func = @self.inputMap[input[0]]
	return func(self, input)
end function
